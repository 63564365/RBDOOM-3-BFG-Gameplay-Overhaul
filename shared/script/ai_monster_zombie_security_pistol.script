/***********************************************************************

ai_monster_zombie_security_pistol.script

monster_zombie_sergeant
monster_zsec_shotgun
monster_zsec_p90_helmet
monster_zsec_p90_zombie
monster_zsec_pistol_shield

***********************************************************************/

#define ZSECP_RUNDISTANCE				192
#define ZSECP_WALKTURN					65
#define ZSECP_DODGE_RATE				5
#define ZSECP_ATTACK_DELAY_MIN			0.5
#define ZSECP_ATTACK_DELAY_MAX			1
#define ZSECP_ATTACK_MAX_LENGTH			3
#define ZSECP_ATTACK_MIN_LENGTH			2
#define ZSECP_WAIT_MIN_LENGTH			0.3
#define ZSECP_WAIT_MAX_LENGTH			0.7
#define ZSECP_CROUCH_ATTACK_MAX_LENGTH	4
#define ZSECP_CROUCH_ATTACK_MIN_LENGTH	2.5
#define ZSECP_STAND_ATTACK_MAX_LENGTH	3
#define ZSECP_STAND_ATTACK_MIN_LENGTH	1.5
#define ZSECP_ATTACK_MIN_SHOOT_TIME		0.5
#define ZSECP_NOFOVTIME					4

#define ZSECP_REPOSITION_MAX_LENGTH		11
#define ZSECP_REPOSITION_MIN_LENGTH		6
#define ZSECP_REPOSITION_DELAY_MAX		6
#define ZSECP_REPOSITION_DELAY_MIN		2
#define ZSECP_PERSONAL_SPACE			40

#define ZSECP_CAUTION_COOLDOWN			20
#define ZSECP_ALERT_COOLDOWN			10

object monster_zombie_security_pistol : monster_zombie_base {
	boolean		fire;
	boolean		crouch_fire;
	boolean		run_attack;
	float		nextDodge;
	float		nextAttack;
	float		nextNoFOVAttack;
	entity		combat_node;

	// Squad logistics
	float		next_squad_search;
	float		living_squad_count;
	monster_zombie_security_pistol	squad1;
	monster_zombie_security_pistol	squad2;
	monster_zombie_security_pistol	squad3;
	monster_zombie_security_pistol	squad4;

	// Squad status
	vector		squad1_last_known_position;
	vector		squad2_last_known_position;
	vector		squad3_last_known_position;
	vector		squad4_last_known_position;

	// Threat status
	boolean		enemy_is_around;
	boolean		enemy_in_sight;
	boolean		enemy_is_aiming_at_me;
	boolean		enemy_is_attacking_me;
	boolean		am_taking_damage;
	vector		last_took_damage_position;
	float		last_took_damage_time;
	vector		enemy_last_seen_from_position;
	vector		enemy_last_known_position;
	float		enemy_last_seen_time;
	float		enemy_last_detected_time;
	boolean		disturbance_exists;
	entity		disturbance_source;
	vector		disturbance_position;
	float		disturbance_time;
	boolean		aim_is_blocked;
	entity		aim_blocked_by;
	boolean		move_is_blocked;
	entity		move_blocked_by;
	boolean		cover_is_valid;

	// Voluntary status
	boolean		am_in_cover;
	boolean		am_attacking;

	// entity
	void		init();

	// states
	void		state_Begin();
	void		state_Idle();
	void		state_Retreat();
	void		state_Advance();
	void		state_Regroup();
	// void		state_Investigate();

	// control
	void		check_status();
	void		check_status_loop();
	float		check_attacks();
	void		do_attack( float attack_flags );

	// actions
	void		crouch_attack();
	void		stand_attack();
	void		retreat();
	void		advance();
	void		regroup();
	// void		investigate();
	void		combat_step_left();
	void		combat_step_right();
	void		combat_dodge_left();
	void		combat_dodge_right();

	// squad
	void		find_squad();
	void		find_squad_loop();
	boolean		add_to_squad( entity team_mate );
	float		check_squad();

	// torso anim states
	void		Torso_Idle();
	void		Torso_Pain();
	void		Torso_RangeAttack();
	void		Torso_TurretAttack();
	void		Torso_CrouchAttack();
	
	// legs anim states
	void		Legs_Idle();
	void		Legs_Walk();
	void		Legs_Run();
	void		Legs_DodgeLeft();
	void		Legs_DodgeRight();
	void		Legs_StepLeft();
	void		Legs_StepRight();
};

/***********************************************************************

	Torso animation control

***********************************************************************/

void monster_zombie_security_pistol::Torso_Idle() {
	idleAnim( ANIMCHANNEL_TORSO, "stand" );
	
	eachFrame {
		if ( enemy_is_around ) {
			sys.println( "[ALERT]" + (ZSECP_ALERT_COOLDOWN - (sys.getTime() - enemy_last_detected_time)) + "/" + ZSECP_ALERT_COOLDOWN);
		} else if ( disturbance_exists ) {
			sys.println( "[CAUTION] " + (ZSECP_CAUTION_COOLDOWN - (sys.getTime() - disturbance_time)) + "/" + ZSECP_CAUTION_COOLDOWN);
		}

		if ( enemy_in_sight ) {
			sys.println( "Contact!" );
		} else if ( enemy_is_around && disturbance_exists ) {
			sys.println( "He's over there!" );
		} else if ( enemy_is_around ) {
			sys.println( "Stay alert!" );
		} else if ( disturbance_exists) {
			sys.println( "I heard something!" );
		} else {
			sys.println( "Area clear." );
		}

		if ( am_taking_damage ) {
			sys.println( "Medic!" );
		} else if ( enemy_is_attacking_me ) {
			sys.println( "Taking fire!" );
		} else if ( enemy_is_aiming_at_me ) {
			sys.println( "Cover me!" );
		}

		if ( enemy_in_sight && aim_is_blocked ) {
			sys.println( "Get out of the way!" );
		}

		if ( enemy_in_sight && move_is_blocked ) {
			sys.println( "You're in my spot!" );
		}

		sys.println( "" );
		continue;

		if ( AI_PAIN ) {
			Torso_Pain();
			idleAnim( ANIMCHANNEL_TORSO, "stand" );
		}
		if ( fire ) {
			animState( ANIMCHANNEL_TORSO, "Torso_RangeAttack", 4 );
		}
		if ( crouch_fire ) {
			animState( ANIMCHANNEL_TORSO, "Torso_CrouchAttack", 4 );
		}
	}
}

void monster_zombie_security_pistol::Torso_Pain() {
	string animname;

	animname = getPainAnim();
	setBlendFrames( ANIMCHANNEL_TORSO, 2 );
	playAnim( ANIMCHANNEL_TORSO, animname );

	while( !animDone( ANIMCHANNEL_TORSO, 4 ) ) {
		waitFrame();
	}
	
	// no pain for 1 second
	preventPain( 1 );
	
	finishAction( "pain" );
	setBlendFrames( ANIMCHANNEL_TORSO, 4 );
}

void monster_zombie_security_pistol::Torso_RangeAttack() {
	float endtime;
	float mintime;
	boolean first_shot;
	
	setAnimPrefix( "" );

	overrideAnim( ANIMCHANNEL_LEGS );
	stopMove();

	playAnim( ANIMCHANNEL_TORSO, "range_attack" );
	while( !animDone( ANIMCHANNEL_TORSO, 0 ) ) {
		if ( AI_PAIN ) {
			Torso_Pain();
		}
		waitFrame();
	}
	
	first_shot = true;
	while( ( fire || first_shot ) && !sys.influenceActive() ) {
		mintime = sys.getTime() + ZSECP_ATTACK_MIN_SHOOT_TIME;
		endtime = RandomDelay( ZSECP_ATTACK_MIN_LENGTH, ZSECP_ATTACK_MAX_LENGTH );
		while( ( fire || ( sys.getTime() < mintime ) ) && ( sys.getTime() < endtime ) ) {
			playAnim( ANIMCHANNEL_TORSO, "range_attack_loop" );
			while( !animDone( ANIMCHANNEL_TORSO, 0 ) ) {
				if ( sys.influenceActive() ) {
					endtime = 0;
					fire = false;
					break;
				}

				if ( AI_FORWARD ) {
					if ( !entityInAttackCone( getEnemy() ) ) {
						endtime = 0;
						fire = false;
						break;
					}
				}

				if ( AI_PAIN ) {
					Torso_Pain();
				}
				waitFrame();
			}
		}

		first_shot = false;
		if ( !fire ) {
			break;
		}

		playCycle( ANIMCHANNEL_TORSO, "range_attack_aim" );
		endtime = RandomDelay( ZSECP_WAIT_MIN_LENGTH, ZSECP_WAIT_MAX_LENGTH );
		while( fire && ( sys.getTime() < endtime ) ) {
			if ( sys.influenceActive() ) {
				fire = false;
				break;
			}
			if ( AI_FORWARD ) {
				if ( !entityInAttackCone( getEnemy() ) ) {
					break;
				}
			}
			if ( AI_PAIN ) {
				Torso_Pain();
			}
			waitFrame();
		}
	}
	
	playAnim( ANIMCHANNEL_TORSO, "range_attack_end" );
	while( !animDone( ANIMCHANNEL_TORSO, 4 ) ) {
		if ( AI_PAIN ) {
			Torso_Pain();
		}
		waitFrame();
	}
	
	finishAction( "range_attack" );
	animState( ANIMCHANNEL_TORSO, "Torso_Idle", 4 );
}

void monster_zombie_security_pistol::Torso_TurretAttack() {
	float endtime;
	float mintime;
	boolean first_shot;
	
	if(getIntKey("turret_crouch")) {
		setAnimPrefix( "crouch" );
	} else {
		setAnimPrefix( "" );
	}
	
		
	playAnim( ANIMCHANNEL_TORSO, "range_attack" );
	while( !animDone( ANIMCHANNEL_TORSO, 0 ) ) {
		if ( AI_PAIN ) {
			Torso_Pain();
		}
		waitFrame();
	}
	
	first_shot = true;
	while( ( first_shot || canHitEnemyFromAnim( "range_attack_loop" ) ) && !sys.influenceActive() ) {
		mintime = sys.getTime() + ZSECP_ATTACK_MIN_SHOOT_TIME;
		endtime = RandomDelay( ZSECP_ATTACK_MIN_LENGTH, ZSECP_ATTACK_MAX_LENGTH );
		while( ( sys.getTime() < mintime ) || ( ( sys.getTime() < endtime ) && canHitEnemyFromAnim( "range_attack_loop" ) ) ) {
			playAnim( ANIMCHANNEL_TORSO, "range_attack_loop" );
			while( !animDone( ANIMCHANNEL_TORSO, 0 ) ) {
				if ( sys.influenceActive() ) {
					endtime = 0;
					break;
				}
				if ( AI_PAIN ) {
					Torso_Pain();
				}
				waitFrame();
			}
		}
		first_shot = false;

		playCycle( ANIMCHANNEL_TORSO, "range_attack_aim" );
		endtime = RandomDelay( ZSECP_WAIT_MIN_LENGTH, ZSECP_WAIT_MAX_LENGTH );
		while( fire && ( sys.getTime() < endtime ) ) {
			if ( sys.influenceActive() ) {
				break;
			}
			if ( AI_PAIN ) {
				Torso_Pain();
			}
			waitFrame();
		}
	}
	
	playAnim( ANIMCHANNEL_TORSO, "range_attack_end" );
	while( !animDone( ANIMCHANNEL_TORSO, 4 ) ) {
		if ( AI_PAIN ) {
			Torso_Pain();
		}
		waitFrame();
	}
	
	finishAction( "turret_attack" );
	animState( ANIMCHANNEL_TORSO, "Torso_Idle", 4 );
}

void monster_zombie_security_pistol::Torso_CrouchAttack() {
	float endtime;
	float mintime;
	boolean first_shot;
	
	overrideAnim( ANIMCHANNEL_LEGS );
	
	setAnimPrefix( "crouch" );

	playAnim( ANIMCHANNEL_TORSO, "range_attack" );
	while( !animDone( ANIMCHANNEL_TORSO, 0 ) ) {
		if ( AI_PAIN ) {
			Torso_Pain();
		}
		waitFrame();
	}

	first_shot = true;
	while( ( crouch_fire || first_shot ) && !sys.influenceActive() ) {
		mintime = sys.getTime() + ZSECP_ATTACK_MIN_SHOOT_TIME;
		endtime = RandomDelay( ZSECP_ATTACK_MIN_LENGTH, ZSECP_ATTACK_MAX_LENGTH );
		while( ( crouch_fire || ( sys.getTime() < mintime ) ) && ( sys.getTime() < endtime ) ) {
			playAnim( ANIMCHANNEL_TORSO, "range_attack_loop" );
			while( !animDone( ANIMCHANNEL_TORSO, 0 ) ) {
				if ( sys.influenceActive() ) {
					crouch_fire = false;
					endtime = 0;
					break;
				}
				if ( AI_PAIN ) {
					Torso_Pain();
				}
				waitFrame();
			}
		}

		first_shot = false;
		if ( !crouch_fire ) {
			break;
		}

		playCycle( ANIMCHANNEL_TORSO, "range_attack_aim" );
		endtime = RandomDelay( ZSECP_WAIT_MIN_LENGTH, ZSECP_WAIT_MAX_LENGTH );
		while( crouch_fire && ( sys.getTime() < endtime ) ) {
			if ( sys.influenceActive() ) {
				crouch_fire = false;
				endtime = 0;
				break;
			}
			if ( AI_PAIN ) {
				Torso_Pain();
			}
			waitFrame();
		}
	}
	
	playAnim( ANIMCHANNEL_TORSO, "range_attack_end" );
	while( !animDone( ANIMCHANNEL_TORSO, 6 ) ) {
		if ( AI_PAIN ) {
			Torso_Pain();
		}
		waitFrame();
	}
	
	finishAction( "crouch_attack" );
	setAnimPrefix( "" );
	
	animState( ANIMCHANNEL_TORSO, "Torso_Idle", 6 );
}

/***********************************************************************

	Legs animation control

***********************************************************************/

void monster_zombie_security_pistol::Legs_Idle() {
	idleAnim( ANIMCHANNEL_LEGS, "stand" );

	eachFrame {
		if ( getEnemy() ) {
			run = true;
		}
		if ( run && AI_FORWARD )	{ animState( ANIMCHANNEL_LEGS, "Legs_Run", 8 ); }
		if ( AI_FORWARD )			{ animState( ANIMCHANNEL_LEGS, "Legs_Walk", 8 ); }
	}
}

void monster_zombie_security_pistol::Legs_Walk() {
	if ( fast ) {
		playCycle( ANIMCHANNEL_LEGS, "fast_walk" );
	} else {
		playCycle( ANIMCHANNEL_LEGS, "walk" );
	}
	
	eachFrame {
		if ( getEnemy() ) {
			run = true;
		}
		if ( run && AI_FORWARD )	{ animState( ANIMCHANNEL_LEGS, "Legs_Run", 8 ); }
		if ( !AI_FORWARD )			{ animState( ANIMCHANNEL_LEGS, "Legs_Idle", 8 ); }
	}
}

void monster_zombie_security_pistol::Legs_Run() {
	if ( fast ) {
		playCycle( ANIMCHANNEL_LEGS, "fast_run" );
	} else {
		playCycle( ANIMCHANNEL_LEGS, "run" );
	}	
	eachFrame {
		if ( getEnemy() ) {
			run = true;
		}
		if ( !run && AI_FORWARD )	{ animState( ANIMCHANNEL_LEGS, "Legs_Walk", 8 ); }
		if ( !AI_FORWARD )			{ animState( ANIMCHANNEL_LEGS, "Legs_Idle", 8 ); }
	}
}

void monster_zombie_security_pistol::Legs_DodgeLeft() {
	playAnim( ANIMCHANNEL_LEGS, "evade_left" );

	while( !animDone( ANIMCHANNEL_LEGS, 8 ) ) {
		waitFrame();
	}
	
	finishAction( "strafe" );
	animState( ANIMCHANNEL_LEGS, "Legs_Idle", 8 );
}

void monster_zombie_security_pistol::Legs_DodgeRight() {
	playAnim( ANIMCHANNEL_LEGS, "evade_right" );

	while( !animDone( ANIMCHANNEL_LEGS, 8 ) ) {
		waitFrame();
	}

	finishAction( "strafe" );
	animState( ANIMCHANNEL_LEGS, "Legs_Idle", 8 );
}

void monster_zombie_security_pistol::Legs_StepLeft() {
	playAnim( ANIMCHANNEL_LEGS, "step_left" );

	while( !animDone( ANIMCHANNEL_LEGS, 4 ) ) {
		waitFrame();
	}
	
	finishAction( "sidestep" );
	animState( ANIMCHANNEL_LEGS, "Legs_Idle", 4 );
}

void monster_zombie_security_pistol::Legs_StepRight() {
	playAnim( ANIMCHANNEL_LEGS, "step_right" );

	while( !animDone( ANIMCHANNEL_LEGS, 4 ) ) {
		waitFrame();
	}

	finishAction( "sidestep" );
	animState( ANIMCHANNEL_LEGS, "Legs_Idle", 4 );
}

/***********************************************************************

	AI

***********************************************************************/

/*
=====================
monster_zombie_security_pistol::init
=====================
*/
void monster_zombie_security_pistol::init() {
	run_distance	= ZSECP_RUNDISTANCE;
	walk_turn		= ZSECP_WALKTURN;
	run_attack		= getIntKey( "run_attack" );
	enemy_last_known_position = getOrigin();
	next_squad_search = 0;

	check_status();

	setState( "state_Begin" );
}

/***********************************************************************

	States

***********************************************************************/

/*
=====================
monster_zombie_security_pistol::state_Begin
=====================
*/
void monster_zombie_security_pistol::state_Begin() {
	fire = false;
	crouch_fire = false;

	animState( ANIMCHANNEL_TORSO, "Torso_Idle", 0 );
	animState( ANIMCHANNEL_LEGS, "Legs_Idle", 0 );

	monster_begin();
	setMoveType( MOVETYPE_ANIM );	
	setState( "state_Idle" );
}

/*
=====================
monster_zombie_security_pistol::state_Idle
=====================
*/
void monster_zombie_security_pistol::state_Idle() {
	wait_for_enemy();

	nextAttack		= 0;
	nextNoFOVAttack = 0;
	nextDodge		= RandomTime( ZSECP_DODGE_RATE );

	setState( "state_Combat" );
}

/***********************************************************************

	attacks

***********************************************************************/

/*
=====================
monster_zombie_security_pistol::do_attack
=====================
*/
void monster_zombie_security_pistol::do_attack( float attack_flags ) {
	nextNoFOVAttack = sys.getTime() + ZSECP_NOFOVTIME;
	if ( attack_flags & ATTACK_DODGE_LEFT ) {
		combat_dodge_left();
	} else if ( attack_flags & ATTACK_DODGE_RIGHT ) {
		combat_dodge_right();
	} else if ( attack_flags & ATTACK_COMBAT_NODE ) {
		combat_ainode( combat_node );
	} else if ( attack_flags & ATTACK_MISSILE ) {
		stand_attack();
	}
}

/*
=====================
monster_zombie_security_pistol::check_attacks
=====================
*/
float monster_zombie_security_pistol::check_attacks() {
	float currentTime;
	float attack_flags;
	boolean try_attack;
	boolean reachable;
	entity enemy;
	player_base player;
	
	attack_flags = 0;
	
	currentTime = sys.getTime();

	if ( ( living_squad_count < 4 ) && ( currentTime > next_squad_search ) ) {
		find_squad();
		next_squad_search = currentTime + 60;
	}

	combat_node = getCombatNode();
	if ( combat_node ) {
		attack_flags |= ATTACK_COMBAT_NODE;
	}

	reachable = canReachEnemy();
	if ( AI_ENEMY_IN_FOV && ( !reachable || ( currentTime >= nextAttack ) ) ) {
		try_attack = true;
	} else if ( ( sys.getTime() > nextNoFOVAttack ) && AI_ENEMY_VISIBLE && ( !reachable || ( currentTime >= nextAttack ) ) ) {
		try_attack = true;
	} else if ( touches( getEnemy() ) ) {
		try_attack = true;
	} else {
		try_attack = false;
	}

	if ( try_attack ) {
		if ( canHitEnemyFromAnim( "range_attack_loop" ) ) {
			attack_flags |= ATTACK_MISSILE;
		}
	}

	return attack_flags;
}

/*
=====================
monster_zombie_security_pistol::stand_attack
=====================
*/
void monster_zombie_security_pistol::stand_attack() {
	float attackTime;
	float endtime;
	float attack_flags;

	fire = true;
	attackTime = RandomDelay( ZSECP_STAND_ATTACK_MIN_LENGTH, ZSECP_STAND_ATTACK_MAX_LENGTH );
	while( AI_ENEMY_VISIBLE ) {
		endtime = RandomDelay( 0.5, 1 );
		while( sys.getTime() < endtime ) {
			if ( sys.influenceActive() ) {
				fire = false;
				break;
			}
			lookAtEnemy( 1 );
			faceEnemy();
			if ( !entityInAttackCone( getEnemy() ) ) {
				attackTime = 0;
				break;
			}
			if ( !canHitEnemyFromAnim( "range_attack_loop" ) ) {
				break;
			}
			if ( AI_PAIN ) {
				attack_flags = check_attacks();
				if ( attack_flags & ( ATTACK_DODGE_LEFT | ATTACK_DODGE_RIGHT ) ) {
					fire = false;
					do_attack( attack_flags );
					return;
				}
			}
			waitFrame();
		}

		if ( sys.influenceActive() ) {
			break;
		}
		
		if ( sys.getTime() > attackTime ) {
			break;
		}

		if ( !AI_ENEMY_VISIBLE || !canHitEnemyFromAnim( "range_attack_loop" ) ) {
			break;
		}
	}
	
	fire = false;
	while( inAnimState( ANIMCHANNEL_TORSO, "Torso_RangeAttack" ) ) {
		waitFrame();
	}

	// don't attack for a bit
	nextAttack = RandomDelay( ZSECP_ATTACK_DELAY_MIN, ZSECP_ATTACK_DELAY_MAX );
	nextNoFOVAttack = sys.getTime() + ZSECP_NOFOVTIME;
}
	
/*
=====================
monster_zombie_security_pistol::crouch_attack
=====================
*/
void monster_zombie_security_pistol::crouch_attack() {
	float attackTime;
	float attack_flags;

	faceEnemy();
	crouch_fire = true;

	attackTime = RandomDelay( ZSECP_CROUCH_ATTACK_MIN_LENGTH, ZSECP_CROUCH_ATTACK_MAX_LENGTH );
	while( AI_ENEMY_VISIBLE ) {
		if ( sys.influenceActive() ) {
			crouch_fire = false;
			break;
		}
		if ( sys.getTime() > attackTime ) {
			break;
		}
		
		if ( AI_PAIN ) {
			attack_flags = check_attacks();
			if ( attack_flags & ( ATTACK_DODGE_LEFT | ATTACK_DODGE_RIGHT ) ) {
				crouch_fire = false;
				setAnimPrefix( "" );
				do_attack( attack_flags );
				return;
			}
		}
		
		lookAtEnemy( 1 );
		if ( !canHitEnemyFromAnim( "range_attack_loop" ) ) {
			break;
		}
		waitFrame();
	}
	
	crouch_fire = false;
	while( inAnimState( ANIMCHANNEL_TORSO, "Torso_CrouchAttack" ) ) {
		waitFrame();
	}

	// don't attack for a bit
	nextAttack = RandomDelay( ZSECP_ATTACK_DELAY_MIN, ZSECP_ATTACK_DELAY_MAX );
	nextNoFOVAttack = sys.getTime() + ZSECP_NOFOVTIME;
}

void monster_zombie_security_pistol::combat_step_left() {
	animState( ANIMCHANNEL_LEGS, "Legs_StepLeft", 4 );
	while( inAnimState( ANIMCHANNEL_LEGS, "Legs_StepLeft" ) ) {
		lookAtEnemy( 1 );
		waitFrame();
	}
}

void monster_zombie_security_pistol::combat_step_right() {
	animState( ANIMCHANNEL_LEGS, "Legs_StepRight", 4 );
	while( inAnimState( ANIMCHANNEL_LEGS, "Legs_StepRight" ) ) {
		lookAtEnemy( 1 );
		waitFrame();
	}
}

/*
=====================
monster_zombie_security_pistol::combat_dodge_left
=====================
*/
void monster_zombie_security_pistol::combat_dodge_left() {
	stopMove();
	faceEnemy();
	animState( ANIMCHANNEL_LEGS, "Legs_DodgeLeft", 2 );
	waitAction( "strafe" );
	nextDodge = DelayTime( ZSECP_DODGE_RATE );
}

/*
=====================
monster_zombie_security_pistol::combat_dodge_right
=====================
*/
void monster_zombie_security_pistol::combat_dodge_right() {
	stopMove();
	faceEnemy();
	animState( ANIMCHANNEL_LEGS, "Legs_DodgeRight", 2 );	
	waitAction( "strafe" );
	nextDodge = DelayTime( ZSECP_DODGE_RATE );
}

/*
=====================
monster_zombie_security_pistol::state_Combat
=====================
*/
void monster_zombie_security_pistol::state_Combat() {
	float attack_flags;

	eachFrame {
		faceEnemy();
		if ( AI_ENEMY_IN_FOV ) {
			lookAtEnemy( 1 );
		}

		if ( sys.influenceActive() ) {
			waitFrame();
			continue;
		}

		if ( AI_ENEMY_DEAD ) {
			enemy_dead();
		}

		attack_flags = check_attacks();
		if ( attack_flags ) {
			do_attack( attack_flags );
			continue;
		}

		waitFrame();
	}
}

void monster_zombie_security_pistol::state_Retreat() {
	retreat();
}

void monster_zombie_security_pistol::state_Advance() {
	advance();
}

void monster_zombie_security_pistol::state_Regroup() {
	regroup();
}

/*
=====================
monster_zombie_security_pistol::retreat
=====================
*/
void monster_zombie_security_pistol::retreat() {
	float cutoffTime;
	float lastTargetedTime;
	float currentTime;
	entity enemy;
	player_base player;

	enemy = getEnemy();
	cutoffTime = RandomDelay( ZSECP_REPOSITION_MIN_LENGTH, ZSECP_REPOSITION_MAX_LENGTH );
	lastTargetedTime = sys.getTime();
	moveToCover();
	if ( AI_DEST_UNREACHABLE || AI_BLOCKED || AI_OBSTACLE_IN_PATH ) {
		moveOutOfRange( getEnemy(), enemyRange() + 500 );
	}
	if ( AI_MOVE_DONE ) {
		cutoffTime = RandomDelay( ZSECP_REPOSITION_MIN_LENGTH / 2, ZSECP_REPOSITION_MAX_LENGTH / 2 );
		wander();
	}
	while ( !AI_ENEMY_DEAD ) {
		currentTime = sys.getTime();

		if ( AI_DEST_UNREACHABLE || AI_BLOCKED || AI_OBSTACLE_IN_PATH ) {
			break;
		}
		if ( AI_ENEMY_VISIBLE ) {
			run = true;
			if ( currentTime > cutoffTime ) {
				break;
			}
			if ( enemy == $player1 ) {
				player = $player1;
				if ( player.TraceView( 1000 ) == self ) {
					lastTargetedTime = currentTime;
				} else if ( currentTime > lastTargetedTime + 2 + sys.random(5) ) {
					break;
				}
			}
		} else {
			if ( currentTime > lastTargetedTime + 2 + sys.random(5) ) {
				run = false;
				break;
			}
		}
		waitFrame();
	}
}

/*
=====================
monster_zombie_security_pistol::advance
=====================
*/
void monster_zombie_security_pistol::advance() {
	float currentTime;
	float cutoffTime;
	boolean do_run;
	float delta;
	vector position;

	if ( !AI_ENEMY_VISIBLE || ( enemyRange() > run_distance ) ) {
		do_run = true;
	} else {
		do_run = false;
	}

	moveToEnemy();
	if ( AI_MOVE_DONE ) {
		moveToPosition( enemy_last_known_position );
	}

	cutoffTime = RandomDelay( ZSECP_REPOSITION_MIN_LENGTH, ZSECP_REPOSITION_MAX_LENGTH );

	while ( !AI_MOVE_DONE && !AI_DEST_UNREACHABLE && !AI_BLOCKED && !AI_OBSTACLE_IN_PATH ) {
		if ( AI_ENEMY_DEAD ) {
			enemy_dead();
		}

		if ( !AI_ENEMY_VISIBLE || ( enemyRange() > run_distance ) ) {
			do_run = true;
		}

		delta = getTurnDelta();
		if ( ( delta > walk_turn ) || ( delta < -walk_turn ) ) {
			run = false;
		} else {
			run = do_run;
		}

		currentTime = sys.getTime();
		if ( AI_ENEMY_VISIBLE ) {
			break;
		} else if ( sys.getTime() > cutoffTime ) {
			break;
		}

		waitFrame();
	}
}

void monster_zombie_security_pistol::regroup() {
	float distance;
	float shortest_distance;
	vector closest_regroup_position;

	shortest_distance = travelDistanceToPoint( squad1_last_known_position );
	closest_regroup_position = squad1_last_known_position;
	distance = travelDistanceToPoint( squad2_last_known_position);
	if ( distance < shortest_distance ) {
		shortest_distance = distance;
		closest_regroup_position = squad2_last_known_position;
	}
	distance = travelDistanceToPoint( squad3_last_known_position );
	if ( distance < shortest_distance ) {
		shortest_distance = distance;
		closest_regroup_position = squad3_last_known_position;
	}
	distance = travelDistanceToPoint( squad4_last_known_position );
	if ( distance < shortest_distance ) {
		shortest_distance = distance;
		closest_regroup_position = squad4_last_known_position;
	}

	moveToPosition( closest_regroup_position );
	while ( !AI_MOVE_DONE && !AI_DEST_UNREACHABLE && !AI_BLOCKED && !AI_OBSTACLE_IN_PATH ) {
		if ( ( AI_ENEMY_VISIBLE && AI_ENEMY_IN_FOV ) || AI_PAIN ) {
			break;
		}
		if ( canSee( squad1 ) || canSee( squad2 ) || canSee( squad3 ) || canSee( squad4 ) ) {
			break;
		}
		waitFrame();
	}
}

void monster_zombie_security_pistol::find_squad() {
	thread find_squad_loop();
}

void monster_zombie_security_pistol::find_squad_loop() {
	string name;
	entity ent;
	float monster_type;
	monster_zombie_security_pistol zsec;
	float i;
	float num_found;
	float dist;

	for( monster_type = 0; monster_type < 8; monster_type++ ) {
		if ( monster_type == 0 ) {
			name = "monster_zsec_pistol_";
		} else if ( monster_type == 1 ) {
			name = "monster_zsec_shotgun_";
		} else if ( monster_type == 2 ) {
			name = "monster_zsec_machinegun_";
		} else if ( monster_type == 3 ) {
			name = "monster_zsec_shield_";
		} else if ( monster_type == 4 ) {
			name = "idAI_monster_zsec_pistol_";
		} else if ( monster_type == 5 ) {
			name = "idAI_monster_zsec_shotgun_";
		} else if ( monster_type == 6 ) {
			name = "idAI_monster_zsec_machinegun_";
		} else if ( monster_type == 7 ) {
			name = "idAI_monster_zsec_shield_";
		}

		for( i = 0; ( i < 1000 ) && ( living_squad_count < 4 ); i++ ) {
			ent = sys.getEntity( name + i );
			if ( ( ent != $null_entity ) && ( ent != self ) ) {
				zsec = ent;
				dist = travelDistanceToEntity(zsec);
				if ( zsec.AI_DEAD ) {
					continue;
				}
				if ( dist < 0 || dist > 1000 ) {
					continue;
				}
				if ( !zsec.add_to_squad( self ) ) {
					continue;
				}
				self.add_to_squad( zsec );
			}
		}
		if ( living_squad_count >= 4 ) {
			break;
		}
	}
}

boolean monster_zombie_security_pistol::add_to_squad( entity team_mate ) {
	if ( ( squad1 == team_mate ) || ( squad2 == team_mate ) || ( squad3 == team_mate ) || ( squad4 == team_mate ) ) {
		return false;
	}

	if ( squad1 == $null_entity ) {
		squad1 = team_mate;
	} else if ( squad2 == $null_entity ) {
		squad2 = team_mate;
	} else if ( squad3 == $null_entity ) {
		squad3 = team_mate;
	} else if ( squad4 == $null_entity ) {
		squad4 = team_mate;
	} else {
		return false;
	}

	living_squad_count++;
	sys.println( "[" + getName() + "] ADDED: " + team_mate.getName() );
	return true;
}

float monster_zombie_security_pistol::check_squad() {
	float total;
	float living = 0;
	float dead = 0;

	if ( squad1 != $null_entity ) {
		if ( squad1.AI_DEAD ) {
			squad1 = $null_entity;
			dead++;
		} else {
			squad1_last_known_position = squad1.getOrigin();
			living++;
		}
	}
	if ( squad2 != $null_entity ) {
		if ( squad2.AI_DEAD ) {
			squad2 = $null_entity;
			dead++;
		} else {
			squad2_last_known_position = squad2.getOrigin();
			living++;
		}
	}
	if ( squad3 != $null_entity ) {
		if ( squad3.AI_DEAD ) {
			squad3 = $null_entity;
			dead++;
		} else {
			squad3_last_known_position = squad3.getOrigin();
			living++;
		}
	}
	if ( squad4 != $null_entity ) {
		if ( squad4.AI_DEAD ) {
			squad4 = $null_entity;
			dead++;
		} else {
			squad4_last_known_position = squad4.getOrigin();
			living++;
		}
	}

	total = living + dead;
	if ( total == 0 ) {
		return 0;
	}
	
	return living / total;
}

void monster_zombie_security_pistol::check_status() {
	thread check_status_loop();
}

void monster_zombie_security_pistol::check_status_loop() {
	float currentTime;
	entity enemy;
	entity ent;
	player_base player;
	vector myPosition;
	boolean canSeeEnemyAimingAtMe;
	boolean amTakingDamage;
	boolean enemyPlayerFiring;

	while ( !AI_DEAD ) {
		currentTime = sys.getTime();
		enemy = getEnemy();
		myPosition = getOrigin();
		amTakingDamage = AI_DAMAGE;
		AI_DAMAGE = false;

		// enemy_in_sight
		// enemy_last_known_position
		// enemy_last_seen_time
		// enemy_last_seen_from_position
		if ( AI_ENEMY_IN_FOV ) {
			enemy_in_sight = true;
			enemy_last_seen_from_position = myPosition;
			enemy_last_known_position = enemy.getOrigin();
			enemy_last_seen_time = currentTime;
		} else {
			enemy_in_sight = false;
		}

		// enemy_is_aiming_at_me
		enemyPlayerFiring = false;
		canSeeEnemyAimingAtMe = false;
		if ( enemy_in_sight && enemy == $player1 ) {
			player = $player1;
			if ( player.TraceView( 1000 ) == self ) {
				canSeeEnemyAimingAtMe = true;
			}
			if ( player.AI_WEAPON_FIRED || player.AI_ATTACK_HELD ) {
				enemyPlayerFiring = true;
			}
		}
		if ( canSeeEnemyAimingAtMe || amTakingDamage ) {
			enemy_is_aiming_at_me = true;
		} else {
			enemy_is_aiming_at_me = false;
		}

		// am_taking_damage
		// last_took_damage_time
		// last_took_damage_position
		if ( amTakingDamage ) {
			am_taking_damage = true;
			last_took_damage_time = currentTime;
			last_took_damage_position = myPosition;
		} else if ( am_taking_damage && ( currentTime > last_took_damage_time + 2 ) ) {
			am_taking_damage = false;
		}

		// enemy_is_attacking_me
		if ( amTakingDamage || ( canSeeEnemyAimingAtMe && enemyPlayerFiring ) ) {
			enemy_is_attacking_me = true;
		} else if ( enemy_is_attacking_me && ( currentTime > last_took_damage_time + 2 ) ) {
			enemy_is_attacking_me = false;
		}

		// enemy_is_around
		if ( enemy_in_sight || enemy_is_attacking_me ) {
			enemy_is_around = true;
			enemy_last_detected_time = currentTime;
		} else if ( squad1.enemy_is_around || squad2.enemy_is_around || squad3.enemy_is_around || squad4.enemy_is_around ) {
			enemy_is_around = true;
		} else if ( enemy_is_around && ( currentTime > enemy_last_detected_time + ZSECP_ALERT_COOLDOWN ) ) {
			enemy_is_around = false;
		}

		// enemy_last_known_position
		// enemy_last_seen_time
		// enemy_last_seen_from_position
		if ( enemy_is_around && !enemy_in_sight ) {
			if ( squad1.enemy_in_sight || squad1.enemy_last_seen_time > enemy_last_seen_time ) {
				enemy_last_known_position = squad1.enemy_last_known_position;
				enemy_last_seen_from_position = squad1.enemy_last_seen_from_position;
				enemy_last_seen_time = squad1.enemy_last_seen_time;
			}
			if ( squad2.enemy_in_sight || squad2.enemy_last_seen_time > enemy_last_seen_time ) {
				enemy_last_known_position = squad2.enemy_last_known_position;
				enemy_last_seen_from_position = squad2.enemy_last_seen_from_position;
				enemy_last_seen_time = squad2.enemy_last_seen_time;
			}
			if ( squad3.enemy_in_sight || squad3.enemy_last_seen_time > enemy_last_seen_time ) {
				enemy_last_known_position = squad3.enemy_last_known_position;
				enemy_last_seen_from_position = squad3.enemy_last_seen_from_position;
				enemy_last_seen_time = squad3.enemy_last_seen_time;
			}
			if ( squad4.enemy_in_sight || squad4.enemy_last_seen_time > enemy_last_seen_time ) {
				enemy_last_known_position = squad4.enemy_last_known_position;
				enemy_last_seen_from_position = squad4.enemy_last_seen_from_position;
				enemy_last_seen_time = squad4.enemy_last_seen_time;
			}
		}

		// disturbance_exists
		// disturbance_source
		// disturbance_position
		// disturbance_time
		ent = heardSound( false );
		if ( ent != $null_entity ) {
			disturbance_exists = true;
			disturbance_source = ent;
			disturbance_position = ent.getOrigin();
			disturbance_time = currentTime;
		} else if ( disturbance_exists ) {
			if ( canSee( disturbance_source ) || ( currentTime > disturbance_time + ZSECP_CAUTION_COOLDOWN ) ) {
				disturbance_exists = false;
			}
		}

		// aim_is_blocked
		// aim_blocked_by
		if ( enemy_in_sight ) {
			ent = TraceEntity( enemy );
			if ( ent == enemy ) {
				aim_is_blocked = false;
				aim_blocked_by = ent;
			} else {
				aim_is_blocked = true;
			}
		}

		// move_is_blocked
		// move_blocked_by
		if ( !AI_MOVE_DONE ) {
			ent = TraceFacingEntity( 40 );
			if ( ent != $null_entity ) {
				move_is_blocked = true;
				move_blocked_by = ent;
			} else {
				move_is_blocked = false;
			}
		}

		// cover_is_valid
		// note: am_in_cover must be set elsewhere
		if ( am_in_cover ) {
			if ( enemy_in_sight || enemy_is_attacking_me ) {
				cover_is_valid = false;
			} else {
				cover_is_valid = true;
			}
		}
	
		waitFrame();
	}
}