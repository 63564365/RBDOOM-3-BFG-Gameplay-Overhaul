/***********************************************************************

ai_monster_zombie_security_pistol.script

monster_zombie_sergeant
monster_zsec_shotgun
monster_zsec_p90_helmet
monster_zsec_p90_zombie
monster_zsec_pistol_shield

***********************************************************************/

#define ZSECP_RUNDISTANCE				192
#define ZSECP_WALKTURN					65

#define ZSECP_REPOSITION_MAX_LENGTH		11
#define ZSECP_REPOSITION_MIN_LENGTH		6
#define ZSECP_COVER_MAX_DURATION		5
#define ZSECP_COVER_MIN_DURATION		2

#define ZSECP_CAUTION_COOLDOWN			120
#define ZSECP_ALERT_COOLDOWN			60

#define ATTACK_ZSECP_CROUCHFIRE			ATTACK_SPECIAL1
#define ATTACK_ZSECP_ADVANCE			ATTACK_SPECIAL2
#define ATTACK_ZSECP_RETREAT			ATTACK_SPECIAL3

object monster_zombie_security_pistol : monster_zombie_base {
	entity		combat_node;

	// voluntary status
	boolean		am_in_cover;
	boolean		am_attacking;
	boolean		am_crouching;

	// animation control
	boolean		anim_fire_loop;
	boolean		anim_fire_attack;
	boolean		anim_fire_aim;
	boolean		anim_crouchfire_anim;
	boolean		anim_left_sidestep;
	boolean		anim_left_dodge;
	boolean		anim_right_sidestep;
	boolean		anim_right_dodge;

	// threat status
	boolean		enemy_is_around;
	boolean		enemy_in_sight;
	boolean		enemy_is_aiming_at_me;
	boolean		enemy_is_attacking_me;
	float		enemy_last_attacked_time;
	boolean		am_taking_damage;
	vector		last_took_damage_position;
	float		last_took_damage_time;
	vector		enemy_last_seen_from_position;
	vector		enemy_last_known_position;
	float		enemy_last_seen_time;
	float		enemy_last_detected_time;
	boolean		disturbance_exists;
	entity		disturbance_source;
	vector		disturbance_position;
	float		disturbance_time;
	boolean		aim_is_blocked;
	entity		aim_blocked_by;
	boolean		can_hit_enemy;
	boolean		move_is_blocked;
	entity		move_blocked_by;
	boolean		am_blocking_aim;
	boolean		am_blocking_move;
	boolean		enemy_is_attacking_squad;
	boolean		can_left_sidestep;
	boolean		can_left_sidestep_into_cover;
	boolean		can_left_sidestep_to_attack;
	boolean		can_left_dodge;
	boolean		can_left_dodge_into_cover;
	boolean		can_left_dodge_to_attack;
	boolean		can_right_sidestep;
	boolean		can_right_sidestep_into_cover;
	boolean		can_right_sidestep_to_attack;
	boolean		can_right_dodge;
	boolean		can_right_dodge_into_cover;
	boolean		can_right_dodge_to_attack;
	float		player_aim_relative;
	float		health_percentage;

	// squad logistics
	float		next_squad_search;
	float		living_squad_count;
	float		dead_squad_count;
	monster_zombie_security_pistol	squad1;
	monster_zombie_security_pistol	squad2;
	monster_zombie_security_pistol	squad3;
	monster_zombie_security_pistol	squad4;
	monster_zombie_security_pistol	enemy_attack_target;

	// entity
	void		init();

	// states
	void		state_Begin();
	void		state_Idle();
	void		state_Controller();

	// control
	void		begin_update_loop();
	void		update_loop();

	// actions
	void		crouch_attack();
	void		stand_attack();
	void		combat_retreat();
	void		combat_advance();

	// torso anim states
	void		Torso_Idle();
	void		Torso_Pain();
	void		Torso_RangeAttack();
	void		Torso_TurretAttack();
	void		Torso_CrouchAttack();
	void		Step_Left();
	void		Step_Right();
	void		Dodge_Left();
	void		Dodge_Right();
	
	// legs anim states
	void		Legs_Idle();
	void		Legs_Walk();
	void		Legs_Run();
	void		Legs_DodgeLeft();
	void		Legs_DodgeRight();
	void		Legs_StepLeft();
	void		Legs_StepRight();
};

/***********************************************************************

	Torso animation control

***********************************************************************/

void monster_zombie_security_pistol::Torso_Idle() {
	idleAnim( ANIMCHANNEL_TORSO, "stand" );

	eachFrame {
		if ( AI_PAIN ) {
			Torso_Pain();
			idleAnim( ANIMCHANNEL_TORSO, "stand" );
		}
		if ( anim_fire_loop ) {
			animState( ANIMCHANNEL_TORSO, "Torso_RangeAttack", 4 );
		}
		if ( anim_crouchfire_anim ) {
			animState( ANIMCHANNEL_TORSO, "Torso_CrouchAttack", 4 );
		}
	}
}

void monster_zombie_security_pistol::Torso_Pain() {
	string animname;

	animname = getPainAnim();
	setBlendFrames( ANIMCHANNEL_TORSO, 2 );
	playAnim( ANIMCHANNEL_TORSO, animname );

	while( !animDone( ANIMCHANNEL_TORSO, 4 ) ) {
		waitFrame();
	}
	
	// no pain for 1 second
	preventPain( 1 );
	
	finishAction( "pain" );
	setBlendFrames( ANIMCHANNEL_TORSO, 4 );
}

void monster_zombie_security_pistol::Torso_RangeAttack() {
	// raise weapon
	playAnim( ANIMCHANNEL_TORSO, "range_attack" );
	while( !animDone( ANIMCHANNEL_TORSO, 0 ) ) {
		if ( AI_PAIN ) {
			Torso_Pain();
		}
		waitFrame();
	}

	// aim until ready
	playCycle( ANIMCHANNEL_TORSO, "range_attack_aim" );
	float attackStartTime = RandomDelay( 0.1, 0.4 );
	while ( anim_fire_loop && ( sys.getTime() < attackStartTime ) ) {
		if ( AI_PAIN ) {
			Torso_Pain();
		}
		waitFrame();
	}

	// attack loop
	while ( anim_fire_loop ) {
		if ( AI_PAIN ) {
			Torso_Pain();
		}
		
		if ( anim_left_sidestep ) {
			Step_Left();
		} else if ( anim_right_sidestep ) {
			Step_Right();
		} else if ( anim_left_dodge ) {
			Dodge_Left();
		} else if ( anim_right_dodge ) {
			Dodge_Right();
		}
		
		if ( anim_fire_attack ) {
			playAnim( ANIMCHANNEL_TORSO, "range_attack_loop" );
			while( anim_fire_attack && !animDone( ANIMCHANNEL_TORSO, 0 ) ) {
				anim_fire_attack = anim_fire_attack && anim_fire_loop;
				if ( AI_PAIN ) {
					Torso_Pain();
				}
				waitFrame();
			}
		}

		if ( anim_fire_aim ) {
			playCycle( ANIMCHANNEL_TORSO, "range_attack_aim" );
			while ( anim_fire_aim ) {
				anim_fire_aim = anim_fire_aim && anim_fire_loop;
				if ( AI_PAIN ) {
					Torso_Pain();
				}
				waitFrame();
			}
		}
		waitFrame();
	}

	// lower weapon
	playAnim( ANIMCHANNEL_TORSO, "range_attack_end" );
	while( !animDone( ANIMCHANNEL_TORSO, 4 ) ) {
		if ( AI_PAIN ) {
			Torso_Pain();
		}
		waitFrame();
	}

	finishAction( "range_attack" );
	animState( ANIMCHANNEL_TORSO, "Torso_Idle", 4 );
}

void monster_zombie_security_pistol::Torso_TurretAttack() {
}

void monster_zombie_security_pistol::Torso_CrouchAttack() {
}

/***********************************************************************

	Legs animation control

***********************************************************************/

void monster_zombie_security_pistol::Legs_Idle() {
	idleAnim( ANIMCHANNEL_LEGS, "stand" );

	eachFrame {
		if ( getEnemy() ) {
			run = true;
		}
		if ( run && AI_FORWARD )	{ animState( ANIMCHANNEL_LEGS, "Legs_Run", 8 ); }
		if ( AI_FORWARD )			{ animState( ANIMCHANNEL_LEGS, "Legs_Walk", 8 ); }
	}
}

void monster_zombie_security_pistol::Legs_Walk() {
	if ( fast ) {
		playCycle( ANIMCHANNEL_LEGS, "fast_walk" );
	} else {
		playCycle( ANIMCHANNEL_LEGS, "walk" );
	}
	
	eachFrame {
		if ( getEnemy() ) {
			run = true;
		}
		if ( run && AI_FORWARD )	{ animState( ANIMCHANNEL_LEGS, "Legs_Run", 8 ); }
		if ( !AI_FORWARD )			{ animState( ANIMCHANNEL_LEGS, "Legs_Idle", 8 ); }
	}
}

void monster_zombie_security_pistol::Legs_Run() {
	if ( fast ) {
		playCycle( ANIMCHANNEL_LEGS, "fast_run" );
	} else {
		playCycle( ANIMCHANNEL_LEGS, "run" );
	}	
	eachFrame {
		if ( getEnemy() ) {
			run = true;
		}
		if ( !run && AI_FORWARD )	{ animState( ANIMCHANNEL_LEGS, "Legs_Walk", 8 ); }
		if ( !AI_FORWARD )			{ animState( ANIMCHANNEL_LEGS, "Legs_Idle", 8 ); }
	}
}

void monster_zombie_security_pistol::Legs_DodgeLeft() {
	playAnim( ANIMCHANNEL_LEGS, "evade_left" );

	while( !animDone( ANIMCHANNEL_LEGS, 8 ) ) {
		waitFrame();
	}
	
	finishAction( "strafe" );
	animState( ANIMCHANNEL_LEGS, "Legs_Idle", 8 );
}

void monster_zombie_security_pistol::Legs_DodgeRight() {
	playAnim( ANIMCHANNEL_LEGS, "evade_right" );

	while( !animDone( ANIMCHANNEL_LEGS, 8 ) ) {
		waitFrame();
	}

	finishAction( "strafe" );
	animState( ANIMCHANNEL_LEGS, "Legs_Idle", 8 );
}

void monster_zombie_security_pistol::Legs_StepLeft() {
	playAnim( ANIMCHANNEL_LEGS, "step_left" );

	while( !animDone( ANIMCHANNEL_LEGS, 4 ) ) {
		waitFrame();
	}
	
	finishAction( "sidestep" );
	animState( ANIMCHANNEL_LEGS, "Legs_Idle", 4 );
}

void monster_zombie_security_pistol::Legs_StepRight() {
	playAnim( ANIMCHANNEL_LEGS, "step_right" );

	while( !animDone( ANIMCHANNEL_LEGS, 4 ) ) {
		waitFrame();
	}

	finishAction( "sidestep" );
	animState( ANIMCHANNEL_LEGS, "Legs_Idle", 4 );
}

/***********************************************************************

	AI

***********************************************************************/

/*
=====================
monster_zombie_security_pistol::init
=====================
*/
void monster_zombie_security_pistol::init() {
	run_distance	= ZSECP_RUNDISTANCE;
	walk_turn		= ZSECP_WALKTURN;
	enemy_last_known_position = getOrigin();
	next_squad_search = 0;

	begin_update_loop();

	setState( "state_Begin" );
}

/***********************************************************************

	States

***********************************************************************/

/*
=====================
monster_zombie_security_pistol::state_Begin
=====================
*/
void monster_zombie_security_pistol::state_Begin() {
	anim_fire_loop = false;
	anim_crouchfire_anim = false;

	animState( ANIMCHANNEL_TORSO, "Torso_Idle", 0 );
	animState( ANIMCHANNEL_LEGS, "Legs_Idle", 0 );

	monster_begin();
	setMoveType( MOVETYPE_ANIM );	
	setState( "state_Idle" );
}

/*
=====================
monster_zombie_security_pistol::state_Idle
=====================
*/
void monster_zombie_security_pistol::state_Idle() {
	wait_for_enemy();
	setState( "state_Combat" );
}

/*
=====================
monster_zombie_security_pistol::state_Controller
=====================
*/
void monster_zombie_security_pistol::state_Controller() {
	float i = 0;
	monster_zombie_security_pistol squad = $null_entity;
	
	while ( i == 0 || squad != $null_entity ) {
		squad = getTarget( i );
	}
}

/***********************************************************************

	attacks

***********************************************************************/

/*
=====================
monster_zombie_security_pistol::stand_attack
=====================
*/
void monster_zombie_security_pistol::stand_attack() {
	float currentTime;
	float breakCoverTime;
	boolean canEnterCover;
	boolean canExitCover;

	anim_fire_loop = true;
	while ( anim_fire_loop ) {
		currentTime = sys.getTime();
		if ( sys.influenceActive() ) {
			anim_fire_loop = false;
			break;
		}
		if ( enemy_is_attacking_me ) {
			// avoid enemy attack
			canEnterCover = !am_in_cover && ( can_left_sidestep_into_cover || can_left_dodge_into_cover || can_right_sidestep_into_cover || can_right_dodge_into_cover );
			if ( canEnterCover ) {
				breakCoverTime = RandomDelay( ZSECP_COVER_MIN_DURATION, ZSECP_COVER_MAX_DURATION );
				if ( can_left_sidestep_into_cover ) {
					anim_left_sidestep = true;
					am_in_cover = true;
				} else if ( can_right_sidestep_into_cover ) {
					anim_right_sidestep = true;
					am_in_cover = true;
				} else if ( can_left_dodge_into_cover ) {
					anim_left_dodge = true;
					am_in_cover = true;
				} else if ( can_right_dodge_into_cover ) {
					anim_right_dodge = true;
					am_in_cover = true;
				}
			} else if ( getEnemy() == $player1 ) {
				if ( player_aim_relative > 0 ) {
					if ( can_left_dodge ) {
						anim_left_dodge = true;
					} else if ( can_left_sidestep ) {
						anim_left_sidestep = true;
					}
				} else {
					if ( can_right_dodge ) {
						anim_right_dodge = true;
					} else if ( can_right_sidestep ) {
						anim_right_sidestep = true;
					}
				}
			}
		}
		
		if ( can_hit_enemy ) {
			anim_fire_attack = true;
		} else {
			if ( !am_in_cover || ( sys.getTime() > breakCoverTime ) ) {
				canExitCover = am_in_cover && ( can_left_sidestep_to_attack || can_left_dodge_to_attack || can_right_sidestep_to_attack || can_right_dodge_to_attack );
				if ( canExitCover ) {
					am_in_cover = false;
				}

				if ( can_left_sidestep_to_attack ) {
					anim_left_sidestep = true;
				} else if ( can_right_sidestep_to_attack ) {
					anim_right_sidestep = true;
				} else if ( can_left_dodge_to_attack ) {
					anim_left_dodge = true;
				} else if ( can_right_dodge_to_attack ) {
					anim_right_dodge = true;
				} else {
					anim_fire_loop = false;
				}
			}
		}

		lookAtEnemy( 1 );
		waitFrame();
	}
	while( inAnimState( ANIMCHANNEL_TORSO, "Torso_RangeAttack" ) ) {
		waitFrame();
	}
}
	
/*
=====================
monster_zombie_security_pistol::crouch_attack
=====================
*/
void monster_zombie_security_pistol::crouch_attack() {
}

void monster_zombie_security_pistol::Step_Left() {
	animState( ANIMCHANNEL_LEGS, "Legs_StepLeft", 4 );
	while( inAnimState( ANIMCHANNEL_LEGS, "Legs_StepLeft" ) ) {
		lookAtEnemy( 1 );
		waitFrame();
	}
	anim_left_sidestep = false;
}

void monster_zombie_security_pistol::Step_Right() {
	animState( ANIMCHANNEL_LEGS, "Legs_StepRight", 4 );
	while( inAnimState( ANIMCHANNEL_LEGS, "Legs_StepRight" ) ) {
		lookAtEnemy( 1 );
		waitFrame();
	}
	anim_right_sidestep = false;
}

/*
=====================
monster_zombie_security_pistol::Dodge_Left
=====================
*/
void monster_zombie_security_pistol::Dodge_Left() {
	stopMove();
	faceEnemy();
	animState( ANIMCHANNEL_LEGS, "Legs_DodgeLeft", 2 );
	waitAction( "strafe" );
	anim_left_dodge = false;
}

/*
=====================
monster_zombie_security_pistol::Dodge_Right
=====================
*/
void monster_zombie_security_pistol::Dodge_Right() {
	stopMove();
	faceEnemy();
	animState( ANIMCHANNEL_LEGS, "Legs_DodgeRight", 2 );	
	waitAction( "strafe" );
	anim_right_dodge = false;
}

/*
=====================
monster_zombie_security_pistol::state_Combat
=====================
*/
void monster_zombie_security_pistol::state_Combat() {
	entity combat_node;

	eachFrame {
		faceEnemy();
		if ( enemy_in_sight ) {
			lookAtEnemy( 1 );
		}

		if ( sys.influenceActive() ) {
			waitFrame();
			continue;
		}

		if ( AI_ENEMY_DEAD ) {
			enemy_dead();
		}
				
		combat_node = getCombatNode();
		if ( combat_node ) {
			combat_ainode( combat_node );
		}
		
		if ( am_taking_damage && ( health_percentage < 0.3 ) ) {
			combat_retreat();
		}
	
		if ( enemy_is_around && !can_hit_enemy ) {
			combat_advance();
		}
	
		if ( can_hit_enemy ) {
			stand_attack();
		}

		waitFrame();
	}
}

/*
=====================
monster_zombie_security_pistol::combat_retreat
=====================
*/
void monster_zombie_security_pistol::combat_retreat() {
	float cutoffTime;
	float currentTime;

	cutoffTime = RandomDelay( ZSECP_REPOSITION_MIN_LENGTH, ZSECP_REPOSITION_MAX_LENGTH );
	moveToCover();
	if ( AI_DEST_UNREACHABLE || AI_BLOCKED || AI_OBSTACLE_IN_PATH || AI_MOVE_DONE ) {
		moveOutOfRange( getEnemy(), enemyRange() + 500 );
	}
	if ( AI_DEST_UNREACHABLE || AI_BLOCKED || AI_OBSTACLE_IN_PATH || AI_MOVE_DONE ) {
		moveToEntity( randomPath() );
	}
	if ( AI_DEST_UNREACHABLE || AI_BLOCKED || AI_OBSTACLE_IN_PATH || AI_MOVE_DONE ) {
		cutoffTime = RandomDelay( ZSECP_REPOSITION_MIN_LENGTH / 2, ZSECP_REPOSITION_MAX_LENGTH / 2 );
		wander();
	}
	while ( enemy_is_around ) {
		currentTime = sys.getTime();
		if ( AI_DEST_UNREACHABLE || AI_BLOCKED || AI_OBSTACLE_IN_PATH || AI_MOVE_DONE ) {
			break;
		}
		if ( enemy_in_sight ) {
			run = true;
			if ( currentTime > cutoffTime ) {
				break;
			}
		} else {
			if ( currentTime > enemy_last_seen_time + 2 ) {
				run = false;
				break;
			}
		}
		waitFrame();
	}
}

/*
=====================
monster_zombie_security_pistol::combat_advance
=====================
*/
void monster_zombie_security_pistol::combat_advance() {
	boolean doRun;
	float delta;
	entity currentDisturbance;

	if ( !enemy_in_sight ) {
		doRun = true;
	} else {
		doRun = false;
	}

	moveToEnemy();
	if ( AI_MOVE_DONE ) {
		if ( disturbance_exists && ( disturbance_time > enemy_last_seen_time ) ) {
			currentDisturbance = disturbance_source;
			moveToPosition( disturbance_position );
		} else {
			moveToPosition( enemy_last_known_position );
		}
	}
	while ( !AI_MOVE_DONE ) {
		if ( disturbance_exists && ( disturbance_time > enemy_last_seen_time ) ) {
			if ( disturbance_source != $null_entity && ( disturbance_source != currentDisturbance ) ) {
				currentDisturbance = disturbance_source;
				moveToPosition( disturbance_position );
			}
		}

		if ( !enemy_in_sight ) {
			doRun = true;
		} else {
			doRun = false;
		}

		delta = getTurnDelta();
		if ( ( delta > walk_turn ) || ( delta < -walk_turn ) ) {
			run = false;
		} else {
			run = doRun;
		}

		if ( can_hit_enemy ) {
			break;
		}

		waitFrame();
	}
	stopMove();
	faceEnemy();
}

void monster_zombie_security_pistol::begin_update_loop() {
	thread update_loop();
}

void monster_zombie_security_pistol::update_loop() {
	float currentTime;
	entity enemy;
	entity ent;
	player_base player;
	vector myPosition;
	boolean canSeeEnemyAimingAtMe;
	boolean amTakingDamage;
	boolean enemyPlayerFiring;
	boolean amBlockingAim;
	boolean amBlockingMove;
	boolean enemyIsAttackingSquad;
	boolean enemyIsAroundSquad;
	float livingSquadCount;
	float lastSquadUpdate;
	vector pos;
	vector dir;
	vector dir_alt;
	vector target;
	float initialHealth;

	initialHealth = getFloatKey( "health" );

	while ( !AI_DEAD ) {
		currentTime = sys.getTime();
		enemy = getEnemy();
		myPosition = getOrigin();
		amTakingDamage = AI_DAMAGE;
		AI_DAMAGE = false;

		// enemy_in_sight
		// enemy_last_known_position
		// enemy_last_seen_time
		// enemy_last_seen_from_position
		if ( AI_ENEMY_IN_FOV ) {
			enemy_in_sight = true;
			enemy_last_seen_from_position = myPosition;
			enemy_last_known_position = enemy.getOrigin();
			enemy_last_seen_time = currentTime;
			can_hit_enemy = canHitEnemyFromAnim( "range_attack_loop" );
		} else {
			enemy_in_sight = false;
			can_hit_enemy = false;
		}

		// enemy_is_aiming_at_me
		enemyPlayerFiring = false;
		canSeeEnemyAimingAtMe = false;
		if ( enemy_in_sight && enemy == $player1 ) {
			player = $player1;
			if ( player.TraceView( 1000 ) == self ) {
				canSeeEnemyAimingAtMe = true;
			}
			if ( player.AI_WEAPON_FIRED || player.AI_ATTACK_HELD ) {
				enemyPlayerFiring = true;
			}
		}
		if ( canSeeEnemyAimingAtMe || amTakingDamage ) {
			enemy_is_aiming_at_me = true;
		} else {
			enemy_is_aiming_at_me = false;
		}

		// am_taking_damage
		// last_took_damage_time
		// last_took_damage_position
		if ( amTakingDamage ) {
			am_taking_damage = true;
			last_took_damage_time = currentTime;
			last_took_damage_position = myPosition;
		} else if ( am_taking_damage && ( currentTime > last_took_damage_time + 2 ) ) {
			am_taking_damage = false;
		}

		// enemy_is_attacking_me
		if ( amTakingDamage || ( canSeeEnemyAimingAtMe && enemyPlayerFiring ) ) {
			enemy_is_attacking_me = true;
			enemy_last_attacked_time = currentTime;
		} else if ( enemy_is_attacking_me && ( currentTime > enemy_last_attacked_time + 2 ) ) {
			enemy_is_attacking_me = false;
		}

		// disturbance_exists
		// disturbance_source
		// disturbance_position
		// disturbance_time
		ent = heardSound( false );
		if ( ent != $null_entity && ent != self ) {
			disturbance_exists = true;
			disturbance_source = ent;
			disturbance_position = ent.getOrigin();
			disturbance_time = currentTime;
		} else if ( disturbance_exists ) {
			if ( canSee( disturbance_source ) || ( currentTime > disturbance_time + ZSECP_CAUTION_COOLDOWN ) ) {
				disturbance_exists = false;
			}
		}

		// aim_is_blocked
		// aim_blocked_by
		if ( enemy_in_sight ) {
			pos = getOrigin() + '0 0 48';
			target = enemy.getOrigin() + '0 0 48';
			sys.trace( pos, target, '-8 -8 0', '8 8 16', MASK_ALL, self );
			ent = sys.getTraceEntity();
			if ( ent == enemy ) {
				aim_is_blocked = false;
				aim_blocked_by = $null_entity;
			} else {
				aim_is_blocked = true;
				aim_blocked_by = ent;
			}
		}

		// move_is_blocked
		// move_blocked_by
		if ( !AI_MOVE_DONE ) {
			ent = getObstacle();
			if ( ent != $null_entity ) {
				move_is_blocked = true;
				move_blocked_by = ent;
			} else {
				move_is_blocked = false;
			}
		}

		// player_aim_relative
		if ( ( enemy == $player1 ) && canSeeEnemyAimingAtMe ) {
			player = $player1;
			target = player.getOrigin() + '0 0 48';
			pos = getOrigin() + '0 0 48';
			dir = pos - target;
			player_aim_relative = sys.DotProduct( dir, sys.angToRight( player.getViewAngles() ) );
		}
		// if ( ang > 0 ) {
		// 	stepLeft = true;
		// } else {
		// 	stepRight = true;
		// }

		// sidestep / evade shared properties
		pos = getOrigin() + '0 0 48';
		dir = sys.angToRight( getAngles() ) * 40;
		dir_alt = dir * 3;
		target = enemy.getOrigin() + '0 0 48';

		// can_right_sidestep_to_attack
		// can_right_sidestep_into_cover
		if ( testAnimMove( "step_right" ) ) {
			can_right_sidestep = true;
			sys.trace( pos + dir, target, '-8 -8 0', '8 8 16', MASK_PLAYERSOLID, self );
			if ( sys.getTraceEntity() == enemy ) {
				can_right_sidestep_to_attack = true;
				can_right_sidestep_into_cover = false;
			} else {
				can_right_sidestep_to_attack = false;
				can_right_sidestep_into_cover = true;
			}
		} else {
			can_right_sidestep = false;
			can_right_sidestep_to_attack = false;
			can_right_sidestep_into_cover = false;
		}

		// can_right_dodge_to_attack
		// can_right_dodge_into_cover
		if ( testAnimMove( "evade_right" ) ) {
			can_right_dodge = true;
			sys.trace( pos + dir_alt, target, '-8 -8 0', '8 8 16', MASK_PLAYERSOLID, self );
			if ( sys.getTraceEntity() == enemy ) {
				can_right_dodge_to_attack = true;
				can_right_dodge_into_cover = false;
			} else {
				can_right_dodge_to_attack = false;
				can_right_dodge_into_cover = true;
			}
		} else {
			can_right_dodge = false;
			can_right_dodge_to_attack = false;
			can_right_dodge_into_cover = false;
		}

		// can_left_sidestep_to_attack
		// can_left_sidestep_into_cover
		if ( testAnimMove( "step_left" ) ) {
			can_left_sidestep = true;
			sys.trace( pos - dir, target, '-8 -8 0', '8 8 16', MASK_PLAYERSOLID, self );
			if ( sys.getTraceEntity() == enemy ) {
				can_left_sidestep_to_attack = true;
				can_left_sidestep_into_cover = false;
			} else {
				can_left_sidestep_to_attack = false;
				can_left_sidestep_into_cover = true;
			}
		} else {
			can_left_sidestep = false;
			can_left_sidestep_to_attack = false;
			can_left_sidestep_into_cover = false;
		}

		// can_left_dodge_to_attack
		// can_left_dodge_into_cover
		if ( testAnimMove( "evade_left" ) ) {
			can_left_dodge = true;
			sys.trace( pos - dir_alt, target, '-8 -8 0', '8 8 16', MASK_PLAYERSOLID, self );
			if ( sys.getTraceEntity() == enemy ) {
				can_left_dodge_to_attack = true;
				can_left_dodge_into_cover = false;
			} else {
				can_left_dodge_to_attack = false;
				can_left_dodge_into_cover = true;
			}
		} else {
			can_left_dodge = false;
			can_left_dodge_to_attack = false;
			can_left_dodge_into_cover = false;
		}

		// // living_squad_count
		// // dead_squad_count
		// // am_blocking_aim
		// // am_blocking_move
		// // enemy_last_known_position
		// // enemy_last_seen_time
		// // enemy_last_seen_from_position
		// // enemy_is_attacking_squad
		// // enemy_attack_target
		// // enemy_is_around
		// enemyIsAroundSquad = false;
		// amBlockingAim = false;
		// amBlockingMove = false;
		// if ( currentTime > lastSquadUpdate + 3 ) {
		// 	lastSquadUpdate = currentTime;
		// 	livingSquadCount = 0;
		// 	if ( squad1 != $null_entity ) {
		// 		if ( squad1.AI_DEAD ) {
		// 			squad1 = $null_entity;
		// 			dead_squad_count++;
		// 		} else {
		// 			livingSquadCount++;
		// 			if ( squad1.aim_is_blocked && squad1.aim_blocked_by == self ) {
		// 				amBlockingAim = true;
		// 			}
		// 			if ( squad1.move_is_blocked && squad1.move_blocked_by == self ) {
		// 				amBlockingMove = true;
		// 			}
		// 			if ( squad1.enemy_is_around ) {
		// 				enemyIsAroundSquad = true;
		// 				if ( !enemy_in_sight ) {
		// 					if ( squad1.enemy_in_sight || ( squad1.enemy_last_seen_time > enemy_last_seen_time ) ) {
		// 						enemy_last_known_position = squad1.enemy_last_known_position;
		// 						enemy_last_seen_from_position = squad1.enemy_last_seen_from_position;
		// 						enemy_last_seen_time = squad1.enemy_last_seen_time;
		// 					}
		// 				}
		// 			}
		// 			if ( squad1.enemy_is_attacking_me ) {
		// 				enemyIsAttackingSquad = true;
		// 				enemy_attack_target = squad1;
		// 			}
		// 		}
		// 	}
		// 	if ( squad2 != $null_entity ) {
		// 		if ( squad2.AI_DEAD ) {
		// 			squad2 = $null_entity;
		// 			dead_squad_count++;
		// 		} else {
		// 			livingSquadCount++;
		// 			if ( squad2.aim_is_blocked && squad2.aim_blocked_by == self ) {
		// 				amBlockingAim = true;
		// 			}
		// 			if ( squad2.move_is_blocked && squad2.move_blocked_by == self ) {
		// 				amBlockingMove = true;
		// 			}
		// 			if ( squad2.enemy_is_around ) {
		// 				enemyIsAroundSquad = true;
		// 				if ( !enemy_in_sight ) {
		// 					if ( squad2.enemy_in_sight || ( squad2.enemy_last_seen_time > enemy_last_seen_time ) ) {
		// 						enemy_last_known_position = squad2.enemy_last_known_position;
		// 						enemy_last_seen_from_position = squad2.enemy_last_seen_from_position;
		// 						enemy_last_seen_time = squad2.enemy_last_seen_time;
		// 					}
		// 				}
		// 			}
		// 			if ( squad2.enemy_is_attacking_me ) {
		// 				enemyIsAttackingSquad = true;
		// 				enemy_attack_target = squad2;
		// 			}
		// 		}
		// 	}
		// 	if ( squad3 != $null_entity ) {
		// 		if ( squad3.AI_DEAD ) {
		// 			squad3 = $null_entity;
		// 			dead_squad_count++;
		// 		} else {
		// 			livingSquadCount++;
		// 			if ( squad3.aim_is_blocked && squad3.aim_blocked_by == self ) {
		// 				amBlockingAim = true;
		// 			}
		// 			if ( squad3.move_is_blocked && squad3.move_blocked_by == self ) {
		// 				amBlockingMove = true;
		// 			}
		// 			if ( squad3.enemy_is_around ) {
		// 				enemyIsAroundSquad = true;
		// 				if ( !enemy_in_sight ) {
		// 					if ( squad3.enemy_in_sight || ( squad3.enemy_last_seen_time > enemy_last_seen_time ) ) {
		// 						enemy_last_known_position = squad3.enemy_last_known_position;
		// 						enemy_last_seen_from_position = squad3.enemy_last_seen_from_position;
		// 						enemy_last_seen_time = squad3.enemy_last_seen_time;
		// 					}
		// 				}
		// 			}
		// 			if ( squad3.enemy_is_attacking_me ) {
		// 				enemyIsAttackingSquad = true;
		// 				enemy_attack_target = squad3;
		// 			}
		// 		}
		// 	}
		// 	if ( squad4 != $null_entity ) {
		// 		if ( squad4.AI_DEAD ) {
		// 			squad4 = $null_entity;
		// 			dead_squad_count++;
		// 		} else {
		// 			livingSquadCount++;
		// 			if ( squad4.aim_is_blocked && squad4.aim_blocked_by == self ) {
		// 				amBlockingAim = true;
		// 			}
		// 			if ( squad4.move_is_blocked && squad4.move_blocked_by == self ) {
		// 				amBlockingMove = true;
		// 			}
		// 			if ( squad4.enemy_is_around ) {
		// 				enemyIsAroundSquad = true;
		// 				if ( !enemy_in_sight ) {
		// 					if ( squad4.enemy_in_sight || ( squad4.enemy_last_seen_time > enemy_last_seen_time ) ) {
		// 						enemy_last_known_position = squad4.enemy_last_known_position;
		// 						enemy_last_seen_from_position = squad4.enemy_last_seen_from_position;
		// 						enemy_last_seen_time = squad4.enemy_last_seen_time;
		// 					}
		// 				}
		// 			}
		// 			if ( squad4.enemy_is_attacking_me ) {
		// 				enemyIsAttackingSquad = true;
		// 				enemy_attack_target = squad4;
		// 			}
		// 		}
		// 	}
		// 	living_squad_count = livingSquadCount;
		// }
		// if ( amBlockingAim ) {
		// 	am_blocking_aim = true;
		// } else {
		// 	am_blocking_aim = false;
		// }
		// if ( amBlockingMove ) {
		// 	am_blocking_move = true;
		// } else {
		// 	am_blocking_move = false;
		// }
		// if ( enemyIsAttackingSquad ) {
		// 	enemy_is_attacking_squad = true;
		// } else {
		// 	enemy_is_attacking_squad = false;
		// }

		// enemy_is_around
		if ( enemy_in_sight || enemy_is_attacking_me || enemyIsAroundSquad ) {
			enemy_is_around = true;
			enemy_last_detected_time = currentTime;
		} else if ( enemy_is_around && ( currentTime > enemy_last_detected_time + ZSECP_ALERT_COOLDOWN ) ) {
			enemy_is_around = false;
		}

		//health_percentage
		health_percentage = getHealth() / initialHealth;

		waitFrame();
	}
}